/**
 * @logue/reverb
 *
 * @description JavaScript Reverb effect class
 * @author Logue <logue@hotmail.co.jp>
 * @copyright 2019-2025 By Masashi Yoshikawa All rights reserved.
 * @license MIT
 * @version 1.3.15
 * @see {@link https://github.com/logue/Reverb.js}
 */

(function(n,s){typeof exports=="object"&&typeof module<"u"?s(exports,require("@thi.ng/colored-noise"),require("@thi.ng/transducers"),require("@thi.ng/random")):typeof define=="function"&&define.amd?define(["exports","@thi.ng/colored-noise","@thi.ng/transducers","@thi.ng/random"],s):(n=typeof globalThis<"u"?globalThis:n||self,s(n.Reverb={},n.coloredNoise,n.transducers,n.random))})(this,function(n,s,p,f){"use strict";const u={version:"1.3.15",date:"2025-03-02T14:58:09.789Z"},r={blue:"blue",brown:"red",green:"green",pink:"pink",red:"red",violet:"violet"},m={noise:"white",scale:1,peaks:2,randomAlgorithm:f.SYSTEM,decay:2,delay:0,reverse:!1,time:2,filterType:"allpass",filterFreq:2200,filterQ:1,mix:.5,once:!1};class o{static version=u.version;static build=u.date;ctx;wetGainNode;dryGainNode;filterNode;convolverNode;outputNode;options;isConnected;noise=s.white;constructor(e,t){this.ctx=e,this.options=Object.assign(m,t),this.wetGainNode=this.ctx.createGain(),this.dryGainNode=this.ctx.createGain(),this.filterNode=this.ctx.createBiquadFilter(),this.convolverNode=this.ctx.createConvolver(),this.outputNode=this.ctx.createGain(),this.isConnected=!1,this.filterType(this.options.filterType),this.setNoise(this.options.noise),this.buildImpulse(),this.mix(this.options.mix)}connect(e){return this.isConnected&&this.options.once?(this.isConnected=!1,this.outputNode):(this.convolverNode.connect(this.filterNode),this.filterNode.connect(this.wetGainNode),e.connect(this.convolverNode),e.connect(this.dryGainNode).connect(this.outputNode),e.connect(this.wetGainNode).connect(this.outputNode),this.isConnected=!0,this.outputNode)}disconnect(e){return this.isConnected&&(this.convolverNode.disconnect(this.filterNode),this.filterNode.disconnect(this.wetGainNode)),this.isConnected=!1,e}mix(e){if(!o.inRange(e,0,1))throw new RangeError("[Reverb.js] Dry/Wet ratio must be between 0 to 1.");this.options.mix=e,this.dryGainNode.gain.value=1-this.options.mix,this.wetGainNode.gain.value=this.options.mix}time(e){if(!o.inRange(e,1,50))throw new RangeError("[Reverb.js] Time length of inpulse response must be less than 50sec.");this.options.time=e,this.buildImpulse()}decay(e){if(!o.inRange(e,0,100))throw new RangeError("[Reverb.js] Inpulse Response decay level must be less than 100.");this.options.decay=e,this.buildImpulse()}delay(e){if(!o.inRange(e,0,100))throw new RangeError("[Reverb.js] Inpulse Response delay time must be less than 100.");this.options.delay=e,this.buildImpulse()}reverse(e){this.options.reverse=e,this.buildImpulse()}filterType(e="allpass"){this.filterNode.type=this.options.filterType=e}filterFreq(e){if(!o.inRange(e,20,2e4))throw new RangeError("[Reverb.js] Filter frequrncy must be between 20 and 20000.");this.options.filterFreq=e,this.filterNode.frequency.value=this.options.filterFreq}filterQ(e){if(!o.inRange(e,0,10))throw new RangeError("[Reverb.js] Filter Q value must be between 0 and 10.");this.options.filterQ=e,this.filterNode.Q.value=this.options.filterQ}peaks(e){this.options.peaks=e,this.buildImpulse()}scale(e){this.options.scale=e,this.buildImpulse()}randomAlgorithm(e){this.options.randomAlgorithm=e,this.buildImpulse()}setNoise(e){switch(this.options.noise=e,e){case r.blue:this.noise=s.blue;break;case r.green:this.noise=s.green;break;case r.pink:this.noise=s.pink;break;case r.red:case r.brown:this.noise=s.red;break;case r.violet:this.noise=s.violet;break;default:this.noise=s.white}this.buildImpulse()}setRandomAlgorythm(e){this.options.randomAlgorithm=e,this.buildImpulse()}static inRange(e,t,h){return(e-t)*(e-h)<=0}buildImpulse(){const e=this.ctx.sampleRate,t=Math.max(e*this.options.time,1),h=e*this.options.delay,l=this.ctx.createBuffer(2,t,e),d=new Float32Array(t),c=new Float32Array(t),b=this.getNoise(t),g=this.getNoise(t);for(let i=0;i<t;i++){let a=0;i<h?(d[i]=0,c[i]=0,a=this.options.reverse??!1?t-(i-h):i-h):a=this.options.reverse??!1?t-i:i,d[i]=(b[i]??0)*(1-a/t)**this.options.decay,c[i]=(g[i]??0)*(1-a/t)**this.options.decay}l.getChannelData(0).set(d),l.getChannelData(1).set(c),this.convolverNode.buffer=l}getNoise(e){return[...p.take(e,this.noise({bins:this.options.peaks,scale:this.options.scale,rnd:this.options.randomAlgorithm}))]}}n.default=o,Object.defineProperty(n,"__esModule",{value:!0})});
